#################################################################
# DH Backdoor exploit tester
#################################################################
# This tool test the backdoored Diffie-Hellman parameters
#
# several tests are availables
################################################################# 

import pdb

################################################################# 
# Helpers
################################################################# 

# colors
class cc:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# Handbook of applied crypto Pollard Rho
def Pollard_rho(public_key, order, generator, modulus, a=0, b=0):
    """ This is the implementation of the algorithm introduced in
    the Handbook of Applied Cryptography chapter 3.6.3
    It is definitely not the latest improvement, 
    nor the parallelizable version.
    You need to know the order of the generator to use it
    """
    # initialization
    alpha = generator # to keep the same variables as in the book
    beta = public_key

    if a != 0 or b != 0: # <- wrong
        x = Mod(power_mod(alpha, a, modulus) * power_mod(beta, b, modulus), modulus)
    else:
        x = Mod(1, modulus)

    x = [x, x]
    a = Mod(a, order)
    a = [a, a]
    b = Mod(b, order)
    b = [b, b]
    
    # iteration function
    def iteration(x, a, b):
        if int(x) % 3 == 1: # x in S_1 (chosen from example)
            x = beta * x
            b = b + 1

        elif int(x) % 3 == 0: # x in S_2
            x = x * x
            a = 2 * a
            b = 2 * b

        else: # x in S_3
            x = alpha * x
            a = a + 1

        return x, a, b

    # loop
    while True:
        # iteration function
        x[0], a[0], b[0] = iteration(x[0], a[0], b[0])

        x[1], a[1], b[1] = iteration(x[1], a[1], b[1])
        x[1], a[1], b[1] = iteration(x[1], a[1], b[1])

        # detect collision
        if x[0] == x[1]:
            r = b[0] - b[1]
            if r != 0:
                return r^-1 * (a[1] - a[0])
            else:
                break
                
    # failure
    a = randint(3, order)
    b = randint(3, order)
    return Pollard_rho(public_key, order, generator, modulus, a, b)


################################################################# 
# Tests
################################################################# 

def test_CM_HSS(small=True):
    print cc.HEADER + "Testing CM-HSS" + cc.END
    # setting
    if small:
        print "* with small parameters"
        n = 409633707987005582696602277955282147643085268801177479120969473217998754460013
        p, q = 251153300769938074253856282383556425027 ,  1631010648600788382336119717304312773519 
        g = 5247633181626135476282744635251118657559312444785916253644290946309843578259
        p_small, q_small    = 244159 ,  1478123 
    else:
        n = 109423519767528224387299888812160571977863549562018651093678167563100502546191068886945691026909693084778891719899174693785122277780438033371574158372385675619909656159680772481231551510253625962961496062192935037274983759709222473441081885293077937396959779852246525852479331345971568935426705321065419729661
        print "* bitsize of n         :", len(bin(n)) - 2
        p, q = 7323720966914812591055941708221331966484585723722438709794411811359163268313938691329827951251267050560591642529907351637378159060836729528663195017591659, 14940973346998489926743945066580524906625114387157803259698606478035694327084592182142273688331448815700547769593757798760429978677185604346516769767175479
        g = 32483850559328188434549894182960886820302303321915126177094908458926091304352160054754046284869862170109997699701542437843827087743586196385161467001830143489899358697855828016839242722985661372269246110402295328611009948505049189522851363742586097464031737426541218090692193647163279329266030382311566123304
        p_small, q_small = 897696227, 2121852613 

    # setup public/private key
    x = randint(2, n-1)
    y = power_mod(g, x, n)
    
    # discrete log modulo p and q
    yp = GF(p)(y)
    yq = GF(q)(y)
    gp = GF(p)(g)
    gq = GF(q)(g)
    xp = discrete_log_rho(yp, gp, ord=p_small)
    xq = discrete_log_rho(yq, gq, ord=q_small)
    xp = int(xp)
    xq = int(xq)

    # reconstructing x mod p_1 p_2
    sol= xp * q_small * inverse_mod(q_small, p_small) + xq * p_small * inverse_mod(p_small, q_small)

    # print solutions
    print "* Extracted key        :", sol
    print "* Alice secret key     :", x
    print "* Alice public key     :", y
    print "* Our public key       :", power_mod(g, sol, n)

    # simulate party 2
    x2 = randint(2, n-1)
    y2 = power_mod(g, x2, n)

    # get keys
    key1 = power_mod(y2, x, n) # real shared key from Alice
    key2 = power_mod(y, x2, n) # real shared key from Bob
    key3 = power_mod(y2, sol, n) # shared key found with solution

    # check shared keys
    print "* Shared key from Alice:", key1
    print "* Shared key from Bob  :", key2
    print "* Shared key extracted :", key3

    if key1 == key2 == key3:
        print cc.OKGREEN + "WE ARE ALL GOOOD :))))" + cc.END
    else:
        print cc.WARNING + "WE ARE NOT GOOOD :((((" + cc.END

def test_CM_HSO(small=True):
    print cc.HEADER + "Testing CM-HSO" + cc.END
    if small:
        n          = 19268137865846626851958850322272856396047197682155895684435307978408373065747222697014496202362311549109907458859894354242607160525182604546874472815394580816196765747126365472731269275061518226655168962439072077412577579238431279581950423379707114550984862594479256455246871653608374555649077669
        p, q             = 570853668478777192365118373180099512009639900914548425401110397888084486494265711768517539762811776026858240145585299695637461850362031048765029103 , 33753199689848300442407066691746986229688883915840287800669896943595783069881176522499940807880422002333485157079701615278175199300918469110179966123
        p_order          = 570853668478777192365118373180099512009639900914548425401110397888084486494265711768517539762811776026858240145585299695637461850362031048765029102
        q_order          = 33753199689848300442407066691746986229688883915840287800669896943595783069881176522499940807880422002333485157079701615278175199300918469110179966122
        p_factors        = [2, 232439, 811231, 1843111, 243707, 1150141, 143593, 867371, 1625719, 208393, 1255757, 835553, 860927, 479513, 1581949, 446713, 455783, 740161, 1148527, 1246711, 1179991, 859801, 389447, 970164681287, 1225109]
        q_factors        = [2, 2016752958443, 844117, 422111, 935581, 1573237, 323903, 1265657, 1462759, 242807, 279863, 1794257, 808363, 1301459, 285631, 792037, 1168523, 1136449, 292183, 1050817, 1626137, 376373, 1664561, 1885703, 1170649]
        g = 2
    else:
        print "* with large parameters"
        n          = 58241465464797171580156170360929630850632529158142493575957485432181187042189882308808007279613047710102322139536822305908066198905064277861430794615941083467503490741435661646165432055301478242556337223593694563317710315194895779596854961808647938418025292231190370476543294795985238598324010161915771917848229429482772496691238378958049020481024354486592532279397224094116102703878872902588866804221740779977294745743523278604114419226413626385748298104696640368932840394815963360582227342824845580549585317202754256238668080743708598356952744347633240278057785629211549202169014351059789519400148926161

        p, q             = 229318818643975409285125457664513918096822059373394403420251890428494282115914328752832053385729542226483842118141800424021826840768995698371958121207493756140805132245695751866265008521984888238775454252652079476726592406243992392765745321205954523385450863504915397536944242707967454734103978187650433487 , 253975952820596273149868459341238469773629679659133627230878794001628569319670156776336266772637590163338558417263899885896349906721378787579552387027834904461714390354635474549089105447962685775222150934840380526506674214183922738239705928307675548843394472280594115088092788191282373094655844171103

        p_order          = 229318818643975409285125457664513918096822059373394403420251890428494282115914328752832053385729542226483842118141800424021826840768995698371958121207493756140805132245695751866265008521984888238775454252652079476726592406243992392765745321205954523385450863504915397536944242707967454734103978187650433486
        q_order          = 253975952820596273149868459341238469773629679659133627230878794001628569319670156776336266772637590163338558417263899885896349906721378787579552387027834904461714390354635474549089105447962685775222150934840380526506674214183922738239705928307675548843394472280594115088092788191282373094655844171102
        p_factors        = [2, 1484275527211, 454547, 550721, 1177549, 1551871, 885427, 746873, 901841, 533327, 920167, 996803, 648937, 202243, 1278619, 1593217, 1386643, 1979147, 872161, 1971209, 1342739, 1616939, 1146221, 1853861, 575063, 1462001, 402299, 1024591, 2093257, 1142473, 379417, 1484257, 875929, 575431, 1520579, 285079, 405487, 1776277, 364691, 1012703, 1929287, 1434887, 1018889, 1894117, 1948097, 624731, 970481, 834991, 813493, 872017, 980999]
        q_factors        = [2, 946565783533, 140627, 1821553, 1605313, 1379491, 211801, 273059, 1511801, 801037, 2086507, 293453, 1062169, 1325903, 1287751, 390703, 308521, 332219, 942257, 771697, 283607, 1055471, 1494989, 2001127, 1920901, 137909, 1070249, 1879817, 1218367, 852833, 373859, 1194023, 591559, 195443, 1048793, 150247, 1187507, 1863247, 203039, 1339153, 1960733, 403043, 1623173, 490271, 1036759, 155741, 1234117, 133979, 726533, 2007091, 1757881]
        g        = 2
    test = True
    if test:
        print "TEST"
        n          = 54364501324001701483040331558149354942536766445682796109841319509989536624125508191704669319180510813339765769192129179216435354897756219505530659883764232406349750489424184191074460904974202830950405012270000325707779418673234051218277279008667589108739304079639606123396710842228824800032747769273
        p, q             = 30120475362239069408846807638500601892762954636495809356705669897058542517029609083769954635082043054857968965831911174821166208635525972818810210027 , 1804901837377921149548419102869162086042773435610154340175979275629619269255341816205578111721271592243603288314884736338110069582863259868663063665899
        p_order          = 30120475362239069408846807638500601892762954636495809356705669897058542517029609083769954635082043054857968965831911174821166208635525972818810210026
        q_order          = 1804901837377921149548419102869162086042773435610154340175979275629619269255341816205578111721271592243603288314884736338110069582863259868663063665898
        p_factors        = [2, 547529912773, 774643, 986959, 1233409, 667643, 1654127, 1854689, 939749, 333779, 444589, 223367, 1011749, 1391729, 1306391, 1617103, 377981, 742439, 1268741, 1899923, 1033349, 980851, 1141597, 155201, 1265167]
        q_factors        = [2, 1208804818847, 1865411, 1698101, 300043, 1907819, 523207, 710351, 1135291, 913447, 1106233, 1597553, 497977, 775627, 857977, 1254941, 1943281, 1894859, 1682831, 404161, 664847, 197359, 1526557, 1852909, 1563707]
        g        = 18957687175599495661743699760679433220188097762858705783048179718820106756218049377841798699676964171359065420140503926847459300905448706513969567891234675675369300977592383997139669346513462615562656422057387128944701160107236547035448297041265085234856588939822975890929303045355401609313364170446

    # debug
    print "* size of large factor :", len(bin(p_factors[1])) - 2
    print "* size of small factor :", len(bin(p_factors[2])) - 2
    print "* bitsize of p         :", len(bin(p)) - 2
    print "* bitsize of n         :", len(bin(n)) - 2

        
    # setup public/private key
    x = randint(2, n-1)
    y = power_mod(g, x, n)

    # Pohlig-Hellman in (p-1)/2
    yp = y % p
    xp = 0
    xp_mod = 1

    for order in p_factors[1:]: # to remove the 2
        print "attempting pollard rho in subgroup of order", order
        # reduce the problem
        new_problem = power_mod(yp, (p-1)//order, p)
        # find a generator of that group
        new_generator = power_mod(g, (p-1)//order, p)
        # Pollard Rho
        new_problem = GF(p)(new_problem)
        new_generator = GF(p)(new_generator)
        new_xp = discrete_log_rho(new_problem, new_generator, order)
        #
        print "found it!", new_xp
        xp = CRT(xp, new_xp, xp_mod, order)
        xp_mod *= order

    # Pohlig-Hellman in (q-1)
    yq = y % q
    xq = 0
    xq_mod = 1

    for order in q_factors: # we need the 2
        print "attempting pollard rho in subgroup of order", order
        # reduce the problem
        new_problem = power_mod(yq, (q-1)//order, q)
        # find a generator of that grouq
        new_generator = power_mod(g, (q-1)//order, q)
        # Qollard Rho
        new_problem = GF(q)(new_problem)
        new_generator = GF(q)(new_generator)
        new_xq = discrete_log_rho(new_problem, new_generator, order)
        #
        print "found it!", new_xq
        xq = CRT(xq, new_xq, xq_mod, order)
        xq_mod *= order

    # CRT
    sol = CRT(xp, xq, xp_mod, xq_mod)

    # print solutions
    print "* Extracted key        :", sol
    print "* Alice secret key     :", x
    print "* Alice public key     :", y
    print "* Our public key       :", power_mod(g, sol, n)

    # simulate party 2
    x2 = randint(2, n-1)
    y2 = power_mod(g, x2, n)

    # get keys
    key1 = power_mod(y2, x, n) # real shared key from Alice
    key2 = power_mod(y, x2, n) # real shared key from Bob
    key3 = power_mod(y2, sol, n) # shared key found with solution

    # check shared keys
    print "* Shared key from Alice:", key1
    print "* Shared key from Bob  :", key2
    print "* Shared key extracted :", key3

    if key1 == key2 == key3:
        print cc.OKGREEN + "WE ARE ALL GOOOD :))))" + cc.END
    else:
        print cc.WARNING + "WE ARE NOT GOOOD :((((" + cc.END
        
################################################################# 
# Main menu
################################################################# 

def main():
    test_CM_HSS()
    test_CM_HSO(small=True)
    #test_CM_HSO(small=False)

if __name__ == "__main__":
    main()

